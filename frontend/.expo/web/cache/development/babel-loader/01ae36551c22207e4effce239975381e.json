{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/extends\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nimport React, { Component } from 'react';\nimport Image from \"react-native-web/dist/exports/Image\";\nimport ImageBackground from \"react-native-web/dist/exports/ImageBackground\";\nimport InteractionManager from \"react-native-web/dist/exports/InteractionManager\";\nimport * as FileSystem from 'expo-file-system';\nimport * as Crypto from 'expo-crypto';\n\nvar CachedImage = function (_Component) {\n  _inherits(CachedImage, _Component);\n\n  var _super = _createSuper(CachedImage);\n\n  function CachedImage() {\n    var _this;\n\n    _classCallCheck(this, CachedImage);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _super.call.apply(_super, [this].concat(args));\n    _this.mounted = true;\n    _this.state = {\n      imgURI: ''\n    };\n    return _this;\n  }\n\n  _createClass(CachedImage, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      var _this2 = this;\n\n      return _regeneratorRuntime.async(function componentDidMount$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              this._interaction = InteractionManager.runAfterInteractions(function _callee() {\n                var filesystemURI;\n                return _regeneratorRuntime.async(function _callee$(_context) {\n                  while (1) {\n                    switch (_context.prev = _context.next) {\n                      case 0:\n                        if (!_this2.props.source.uri) {\n                          _context.next = 6;\n                          break;\n                        }\n\n                        _context.next = 3;\n                        return _regeneratorRuntime.awrap(_this2.getImageFilesystemKey(_this2.props.source.uri));\n\n                      case 3:\n                        filesystemURI = _context.sent;\n                        _context.next = 6;\n                        return _regeneratorRuntime.awrap(_this2.loadImage(filesystemURI, _this2.props.source.uri));\n\n                      case 6:\n                      case \"end\":\n                        return _context.stop();\n                    }\n                  }\n                }, null, null, null, Promise);\n              });\n\n            case 1:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate() {\n      var filesystemURI;\n      return _regeneratorRuntime.async(function componentDidUpdate$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              if (!this.props.source.uri) {\n                _context3.next = 8;\n                break;\n              }\n\n              _context3.next = 3;\n              return _regeneratorRuntime.awrap(this.getImageFilesystemKey(this.props.source.uri));\n\n            case 3:\n              filesystemURI = _context3.sent;\n\n              if (!(this.props.source.uri === this.state.imgURI || filesystemURI === this.state.imgURI)) {\n                _context3.next = 6;\n                break;\n              }\n\n              return _context3.abrupt(\"return\", null);\n\n            case 6:\n              _context3.next = 8;\n              return _regeneratorRuntime.awrap(this.loadImage(filesystemURI, this.props.source.uri));\n\n            case 8:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      return _regeneratorRuntime.async(function componentWillUnmount$(_context4) {\n        while (1) {\n          switch (_context4.prev = _context4.next) {\n            case 0:\n              this._interaction && this._interaction.cancel();\n              this.mounted = false;\n              _context4.next = 4;\n              return _regeneratorRuntime.awrap(this.checkClear());\n\n            case 4:\n            case \"end\":\n              return _context4.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"checkClear\",\n    value: function checkClear() {\n      var t, filesystemURI, metadata;\n      return _regeneratorRuntime.async(function checkClear$(_context5) {\n        while (1) {\n          switch (_context5.prev = _context5.next) {\n            case 0:\n              _context5.prev = 0;\n\n              if (!this.downloadResumable) {\n                _context5.next = 14;\n                break;\n              }\n\n              _context5.next = 4;\n              return _regeneratorRuntime.awrap(this.downloadResumable.pauseAsync());\n\n            case 4:\n              t = _context5.sent;\n              _context5.next = 7;\n              return _regeneratorRuntime.awrap(this.getImageFilesystemKey(this.props.source.uri));\n\n            case 7:\n              filesystemURI = _context5.sent;\n              _context5.next = 10;\n              return _regeneratorRuntime.awrap(FileSystem.getInfoAsync(filesystemURI));\n\n            case 10:\n              metadata = _context5.sent;\n\n              if (!metadata.exists) {\n                _context5.next = 14;\n                break;\n              }\n\n              _context5.next = 14;\n              return _regeneratorRuntime.awrap(FileSystem.deleteAsync(t.fileUri));\n\n            case 14:\n              _context5.next = 19;\n              break;\n\n            case 16:\n              _context5.prev = 16;\n              _context5.t0 = _context5[\"catch\"](0);\n              console.log(_context5.t0);\n\n            case 19:\n            case \"end\":\n              return _context5.stop();\n          }\n        }\n      }, null, this, [[0, 16]], Promise);\n    }\n  }, {\n    key: \"getImageFilesystemKey\",\n    value: function getImageFilesystemKey(remoteURI) {\n      var hashed;\n      return _regeneratorRuntime.async(function getImageFilesystemKey$(_context6) {\n        while (1) {\n          switch (_context6.prev = _context6.next) {\n            case 0:\n              _context6.next = 2;\n              return _regeneratorRuntime.awrap(Crypto.digestStringAsync(Crypto.CryptoDigestAlgorithm.SHA256, remoteURI));\n\n            case 2:\n              hashed = _context6.sent;\n              return _context6.abrupt(\"return\", \"\" + FileSystem.documentDirectory + hashed);\n\n            case 4:\n            case \"end\":\n              return _context6.stop();\n          }\n        }\n      }, null, null, null, Promise);\n    }\n  }, {\n    key: \"loadImage\",\n    value: function loadImage(filesystemURI, remoteURI) {\n      var _this3 = this;\n\n      var metadata, imageObject, _metadata;\n\n      return _regeneratorRuntime.async(function loadImage$(_context7) {\n        while (1) {\n          switch (_context7.prev = _context7.next) {\n            case 0:\n              if (this.downloadResumable && this.downloadResumable._removeSubscription) {\n                this.downloadResumable._removeSubscription();\n              }\n\n              _context7.prev = 1;\n              _context7.next = 4;\n              return _regeneratorRuntime.awrap(FileSystem.getInfoAsync(filesystemURI));\n\n            case 4:\n              metadata = _context7.sent;\n\n              if (!metadata.exists) {\n                _context7.next = 8;\n                break;\n              }\n\n              this.setState({\n                imgURI: filesystemURI\n              });\n              return _context7.abrupt(\"return\");\n\n            case 8:\n              this.downloadResumable = FileSystem.createDownloadResumable(remoteURI, filesystemURI, {}, function (dp) {\n                return _this3.onDownloadUpdate(dp);\n              });\n              _context7.next = 11;\n              return _regeneratorRuntime.awrap(this.downloadResumable.downloadAsync());\n\n            case 11:\n              imageObject = _context7.sent;\n\n              if (this.mounted) {\n                if (imageObject && imageObject.status == '200') {\n                  this.setState({\n                    imgURI: imageObject.uri\n                  });\n                }\n              }\n\n              _context7.next = 25;\n              break;\n\n            case 15:\n              _context7.prev = 15;\n              _context7.t0 = _context7[\"catch\"](1);\n              console.log('Image download error:', _context7.t0);\n\n              if (this.mounted) {\n                this.setState({\n                  imgURI: null\n                });\n              }\n\n              _context7.next = 21;\n              return _regeneratorRuntime.awrap(FileSystem.getInfoAsync(filesystemURI));\n\n            case 21:\n              _metadata = _context7.sent;\n\n              if (!_metadata.exists) {\n                _context7.next = 25;\n                break;\n              }\n\n              _context7.next = 25;\n              return _regeneratorRuntime.awrap(FileSystem.deleteAsync(filesystemURI));\n\n            case 25:\n            case \"end\":\n              return _context7.stop();\n          }\n        }\n      }, null, this, [[1, 15]], Promise);\n    }\n  }, {\n    key: \"onDownloadUpdate\",\n    value: function onDownloadUpdate(downloadProgress) {\n      if (downloadProgress.totalBytesWritten >= downloadProgress.totalBytesExpectedToWrite) {\n        if (this.downloadResumable && this.downloadResumable._removeSubscription) {\n          this.downloadResumable._removeSubscription();\n        }\n\n        this.downloadResumable = null;\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var source = this.state.imgURI ? {\n        uri: this.state.imgURI\n      } : null;\n\n      if (!source && this.props.source) {\n        source = _objectSpread(_objectSpread({}, this.props.source), {}, {\n          cache: 'force-cache'\n        });\n      }\n\n      if (this.props.isBackground) {\n        return React.createElement(ImageBackground, _extends({}, this.props, {\n          source: source\n        }), this.props.children);\n      } else {\n        return React.createElement(Image, _extends({}, this.props, {\n          source: source\n        }));\n      }\n    }\n  }]);\n\n  return CachedImage;\n}(Component);\n\nexport { CachedImage as default };","map":{"version":3,"sources":["/Users/jimymarletta/Downloads/instagram_redesign_release_v2/frontend/node_modules/react-native-expo-cached-image/index.js"],"names":["React","Component","FileSystem","Crypto","CachedImage","mounted","state","imgURI","_interaction","InteractionManager","runAfterInteractions","props","source","uri","getImageFilesystemKey","filesystemURI","loadImage","cancel","checkClear","downloadResumable","pauseAsync","t","getInfoAsync","metadata","exists","deleteAsync","fileUri","console","log","remoteURI","digestStringAsync","CryptoDigestAlgorithm","SHA256","hashed","documentDirectory","_removeSubscription","setState","createDownloadResumable","dp","onDownloadUpdate","downloadAsync","imageObject","status","downloadProgress","totalBytesWritten","totalBytesExpectedToWrite","cache","isBackground","children"],"mappings":"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","sourcesContent":["import React, { Component } from 'react';\nimport { Image, ImageBackground, InteractionManager } from 'react-native';\nimport * as FileSystem from 'expo-file-system';\nimport * as Crypto from 'expo-crypto';\n\nexport default class CachedImage extends Component {\n  mounted = true;\n  state = {\n    imgURI: '',\n  };\n\n  async componentDidMount() {\n    this._interaction = InteractionManager.runAfterInteractions(async () => {\n      if (this.props.source.uri) {\n        const filesystemURI = await this.getImageFilesystemKey(this.props.source.uri);\n        await this.loadImage(filesystemURI, this.props.source.uri);\n      }\n    });\n  }\n\n  async componentDidUpdate() {\n    if (this.props.source.uri) {\n      const filesystemURI = await this.getImageFilesystemKey(this.props.source.uri);\n      if (this.props.source.uri === this.state.imgURI || filesystemURI === this.state.imgURI) {\n        return null;\n      }\n      await this.loadImage(filesystemURI, this.props.source.uri);\n    }\n  }\n\n  async componentWillUnmount() {\n    this._interaction && this._interaction.cancel();\n    this.mounted = false;\n    await this.checkClear();\n  }\n\n  async checkClear() {\n    try {\n      if (this.downloadResumable) {\n        const t = await this.downloadResumable.pauseAsync();\n        const filesystemURI = await this.getImageFilesystemKey(this.props.source.uri);\n        const metadata = await FileSystem.getInfoAsync(filesystemURI);\n        if (metadata.exists) {\n          await FileSystem.deleteAsync(t.fileUri);\n        }\n      }\n    } catch (error) {\n      console.log(error);\n    }\n  }\n\n  async getImageFilesystemKey(remoteURI) {\n    const hashed = await Crypto.digestStringAsync(Crypto.CryptoDigestAlgorithm.SHA256, remoteURI);\n    return `${FileSystem.documentDirectory}${hashed}`;\n  }\n\n  async loadImage(filesystemURI, remoteURI) {\n    if (this.downloadResumable && this.downloadResumable._removeSubscription) {\n      this.downloadResumable._removeSubscription();\n    }\n    try {\n      // Use the cached image if it exists\n      const metadata = await FileSystem.getInfoAsync(filesystemURI);\n      if (metadata.exists) {\n        this.setState({\n          imgURI: filesystemURI,\n        });\n        return;\n      }\n\n      // otherwise download to cache\n      this.downloadResumable = FileSystem.createDownloadResumable(\n        remoteURI,\n        filesystemURI,\n        {},\n        (dp) => this.onDownloadUpdate(dp)\n      );\n\n      const imageObject = await this.downloadResumable.downloadAsync();\n      if (this.mounted) {\n        if (imageObject && imageObject.status == '200') {\n          this.setState({\n            imgURI: imageObject.uri,\n          });\n        }\n      }\n    } catch (err) {\n      console.log('Image download error:', err);\n      if (this.mounted) {\n        this.setState({ imgURI: null });\n      }\n      const metadata = await FileSystem.getInfoAsync(filesystemURI);\n      if (metadata.exists) {\n        await FileSystem.deleteAsync(filesystemURI);\n      }\n    }\n  }\n\n  onDownloadUpdate(downloadProgress) {\n    if (downloadProgress.totalBytesWritten >= downloadProgress.totalBytesExpectedToWrite) {\n      if (this.downloadResumable && this.downloadResumable._removeSubscription) {\n        this.downloadResumable._removeSubscription();\n      }\n      this.downloadResumable = null;\n    }\n  }\n\n  render() {\n    let source = this.state.imgURI ? { uri: this.state.imgURI } : null;\n    if (!source && this.props.source) {\n      source = { ...this.props.source, cache: 'force-cache' };\n    }\n    if (this.props.isBackground) {\n      return (\n        <ImageBackground {...this.props} source={source}>\n          {this.props.children}\n        </ImageBackground>\n      );\n    } else {\n      return <Image {...this.props} source={source} />;\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}